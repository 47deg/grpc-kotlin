package io.grpc.examples.helloworld

import io.grpc.CallOptions
import io.grpc.CallOptions.DEFAULT
import io.grpc.Channel
import io.grpc.Metadata
import io.grpc.ServerServiceDefinition
import io.grpc.ServerServiceDefinition.builder
import io.grpc.Status
import io.grpc.Status.UNIMPLEMENTED
import io.grpc.StatusException
import io.grpc.examples.helloworld.GreeterGrpc.getServiceDescriptor
import io.grpc.kotlin.AbstractCoroutineServerImpl
import io.grpc.kotlin.AbstractCoroutineStub
import io.grpc.kotlin.ClientCalls.bidiStreamingRpc
import io.grpc.kotlin.ClientCalls.clientStreamingRpc
import io.grpc.kotlin.ClientCalls.serverStreamingRpc
import io.grpc.kotlin.ClientCalls.unaryRpc
import io.grpc.kotlin.ServerCalls.bidiStreamingServerMethodDefinition
import io.grpc.kotlin.ServerCalls.clientStreamingServerMethodDefinition
import io.grpc.kotlin.ServerCalls.serverStreamingServerMethodDefinition
import io.grpc.kotlin.ServerCalls.unaryServerMethodDefinition
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext
import kotlin.jvm.JvmOverloads
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.SendChannel
import kotlinx.coroutines.withContext

/**
 * Holder for Kotlin coroutine-based client and server APIs for helloworld.Greeter.
 */
object GreeterGrpcKt {
  /**
   * A stub for issuing RPCs to a(n) helloworld.Greeter service as suspending coroutines.
   */
  class GreeterCoroutineStub @JvmOverloads constructor(
    channel: Channel,
    coroutineContext: CoroutineContext = EmptyCoroutineContext,
    callOptions: CallOptions = DEFAULT
  ) : AbstractCoroutineStub<GreeterCoroutineStub>(channel, coroutineContext, callOptions) {
    override fun build(
      channel: Channel,
      coroutineContext: CoroutineContext,
      callOptions: CallOptions
    ): GreeterCoroutineStub = GreeterCoroutineStub(channel, coroutineContext, callOptions)

    /**
     * Issues a unary helloworld.Greeter.SayHello RPC on this stub's [Channel].
     *
     * The implementation may launch further coroutines, which are run as if by
     * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
     * [java.util.concurrent.Executor] associated with the `Channel`.)
     *
     * @param request The single argument to the RPC, sent to the server.
     *
     * @return The single response from the server.  This coroutine suspends until the server
     * returns it and closes with [Status.OK], at which point this coroutine resumes with the
     * result. If the RPC fails (closes with another [Status]), this will fail with a
     * corresponding [StatusException].
     */
    suspend fun sayHello(request: HelloRequest, headers: Metadata = Metadata()): HelloReply =
        withContext(coroutineContext) {
      unaryRpc(
        this,
        channel,
        GreeterGrpc.getSayHelloMethod(),
        request,
        callOptions,
        headers
      )
    }
    /**
     * Issues a client streaming helloworld.Greeter.ClientStreamSayHello RPC on this stub's
     * [Channel].
     *
     * The implementation may launch further coroutines, which are run as if by
     * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
     * [java.util.concurrent.Executor] associated with the `Channel`.)
     *
     * @param requests A [ReceiveChannel] of requests to be sent to the server;
     * expected to be provided, populated, and closed by the client.  When requests is closed,
     * the RPC stream will be closed; if it is closed with a nonnull cause, the RPC is cancelled
     * and the cause is sent to the server as the reason for cancellation.
     *
     * @return The single response from the server.  This coroutine suspends until the server
     * returns it and closes with [Status.OK], at which point this coroutine resumes with the
     * result. If the RPC fails (closes with another [Status]), this will fail with a
     * corresponding [StatusException].
     */
    suspend fun clientStreamSayHello(requests: ReceiveChannel<HelloRequest>, headers: Metadata =
        Metadata()): HelloReply = withContext(coroutineContext) {
      clientStreamingRpc(
        this,
        channel,
        GreeterGrpc.getClientStreamSayHelloMethod(),
        requests,
        callOptions,
        headers
      )
    }
    /**
     * Issues a server streaming helloworld.Greeter.ServerStreamSayHello RPC on this stub's
     * [Channel].
     *
     * The implementation may launch further coroutines, which are run as if by
     * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
     * [java.util.concurrent.Executor] associated with the `Channel`.)
     *
     * @param request The single argument to the RPC, sent to the server.
     *
     * @return A [`ReceiveChannel<HelloReply>`][ReceiveChannel] for responses from the server.  If
     * cancelled, the RPC is shut down and a cancellation with that cause is sent to the server.
     * Alternately, if the RPC fails (closes with a [Status] other than `Status.OK`), the
     * returned channel is [closed][kotlinx.coroutines.channels.SendChannel.close] with a
     * corresponding [StatusException].
     */
    fun serverStreamSayHello(request: MultiHelloRequest, headers: Metadata = Metadata()):
        ReceiveChannel<HelloReply> = serverStreamingRpc(
      CoroutineScope(coroutineContext),
      channel,
      GreeterGrpc.getServerStreamSayHelloMethod(),
      request,
      callOptions,
      headers
    )
    /**
     * Issues a bidirectional streaming helloworld.Greeter.BidiStreamSayHello RPC on this stub's
     * [Channel].
     *
     * The implementation may launch further coroutines, which are run as if by
     * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
     * [java.util.concurrent.Executor] associated with the `Channel`.)
     *
     * @param requests A [ReceiveChannel] of requests to be sent to the server;
     * expected to be provided, populated, and closed by the client.  When requests is closed,
     * the RPC stream will be closed; if it is closed with a nonnull cause, the RPC is cancelled
     * and the cause is sent to the server as the reason for cancellation.
     *
     * @return A [`ReceiveChannel<HelloReply>`][ReceiveChannel] for responses from the server.  If
     * cancelled, the RPC is shut down and a cancellation with that cause is sent to the server.
     * Alternately, if the RPC fails (closes with a [Status] other than `Status.OK`), the
     * returned channel is [closed][kotlinx.coroutines.channels.SendChannel.close] with a
     * corresponding [StatusException].
     */
    fun bidiStreamSayHello(requests: ReceiveChannel<HelloRequest>, headers: Metadata = Metadata()):
        ReceiveChannel<HelloReply> = bidiStreamingRpc(
      CoroutineScope(coroutineContext),
      channel,
      GreeterGrpc.getBidiStreamSayHelloMethod(),
      requests,
      callOptions,
      headers
    )}

  /**
   * Skeletal implementation of the helloworld.Greeter service based on Kotlin coroutines.
   */
  abstract class GreeterCoroutineImplBase(coroutineContext: CoroutineContext =
      EmptyCoroutineContext) : AbstractCoroutineServerImpl(coroutineContext) {
    /**
     * Implements helloworld.Greeter.SayHello as a coroutine.
     *
     * When gRPC receives a helloworld.Greeter.SayHello RPC, gRPC will invoke this method within the
     * [CoroutineContext] used to create this `GreeterCoroutineImplBase`.
     *
     * If this method returns a response successfully, gRPC will send the response to the client
     *  and close the RPC with [Status.OK].
     *
     * If this method throws an exception, the server will not send any responses and close the
     * RPC with a [Status] [inferred][io.grpc.Status.fromThrowable] from the thrown exception.
     * Other
     * RPCs will not be affected.
     *
     * @param request The request sent by the client.
     *
     * @return The response to send to the client.
     */
    open suspend fun sayHello(request: HelloRequest): HelloReply {
      throw
          StatusException(UNIMPLEMENTED.withDescription("Method helloworld.Greeter.SayHello is unimplemented"))
    }

    /**
     * Implements helloworld.Greeter.ClientStreamSayHello as a coroutine.
     *
     * When gRPC receives a helloworld.Greeter.ClientStreamSayHello RPC, gRPC will invoke this
     * method within the
     * [CoroutineContext] used to create this `GreeterCoroutineImplBase`.
     *
     * If this method returns a response successfully, gRPC will send the response to the client
     *  and close the RPC with [Status.OK].
     *
     * If this method throws an exception, the server will not send any responses and close the
     * RPC with a [Status] [inferred][io.grpc.Status.fromThrowable] from the thrown exception.
     * Other
     * RPCs will not be affected.
     *
     * @param requests A [ReceiveChannel] where client requests can be read.
     *       [Cancelling][ReceiveChannel.cancel] this channel can be used to indicate that
     *       further client requests should be discarded.
     *
     * @return The response to send to the client.
     */
    open suspend fun clientStreamSayHello(requests: ReceiveChannel<HelloRequest>): HelloReply {
      throw
          StatusException(UNIMPLEMENTED.withDescription("Method helloworld.Greeter.ClientStreamSayHello is unimplemented"))
    }

    /**
     * Implements helloworld.Greeter.ServerStreamSayHello as a coroutine.
     *
     * When gRPC receives a helloworld.Greeter.ServerStreamSayHello RPC, gRPC will invoke this
     * method within the
     * [CoroutineContext] used to create this `GreeterCoroutineImplBase`.
     *
     * If this method completes without throwing an exception, gRPC will close the
     * `responses` channel (if it is not already closed), finish sending any messages
     * remaining in it, and close the RPC with [Status.OK].  Note that if other coroutines
     * are still writing to `responses`, they may get a
     * [kotlinx.coroutines.channels.ClosedSendChannelException].  Make
     * sure all responses are sent before this method completes, e.g. by wrapping your
     * implementation in [kotlinx.coroutines.coroutineScope] or explicitly
     * [joining][kotlinx.coroutines.Job.join] the jobs
     * that are sending responses.
     *
     * If this method throws an exception, the server will abort sending responses and close the
     * RPC with a [Status] [inferred][io.grpc.Status.fromThrowable] from the thrown exception. Other
     * RPCs will not be affected.
     *
     * @param request The request sent by the client.
     *
     * @param responses A [SendChannel] to send responses to.  Explicitly closing this
     * channel when the RPC is done is optional.  If this channel is closed with a nonnull cause,
     * the RPC will be closed with a [Status] [inferred][Status.fromException] from that
     * cause.  [Sending][kotlinx.coroutines.channels.SendChannel.send] to this channel may suspend
     * if additional responses
     * cannot be sent without excess buffering; see [io.grpc.ServerCall.Listener.onReady] for
     * details.
     */
    open suspend fun serverStreamSayHello(request: MultiHelloRequest,
        responses: SendChannel<HelloReply>) {
      throw
          StatusException(UNIMPLEMENTED.withDescription("Method helloworld.Greeter.ServerStreamSayHello is unimplemented"))
    }

    /**
     * Implements helloworld.Greeter.BidiStreamSayHello as a coroutine.
     *
     * When gRPC receives a helloworld.Greeter.BidiStreamSayHello RPC, gRPC will invoke this method
     * within the
     * [CoroutineContext] used to create this `GreeterCoroutineImplBase`.
     *
     * If this method completes without throwing an exception, gRPC will close the
     * `responses` channel (if it is not already closed), finish sending any messages
     * remaining in it, and close the RPC with [Status.OK].  Note that if other coroutines
     * are still writing to `responses`, they may get a
     * [kotlinx.coroutines.channels.ClosedSendChannelException].  Make
     * sure all responses are sent before this method completes, e.g. by wrapping your
     * implementation in [kotlinx.coroutines.coroutineScope] or explicitly
     * [joining][kotlinx.coroutines.Job.join] the jobs
     * that are sending responses.
     *
     * If this method throws an exception, the server will abort sending responses and close the
     * RPC with a [Status] [inferred][io.grpc.Status.fromThrowable] from the thrown exception. Other
     * RPCs will not be affected.
     *
     * @param requests A [ReceiveChannel] where client requests can be read.
     *       [Cancelling][ReceiveChannel.cancel] this channel can be used to indicate that
     *       further client requests should be discarded.
     *
     * @param responses A [SendChannel] to send responses to.  Explicitly closing this
     * channel when the RPC is done is optional.  If this channel is closed with a nonnull cause,
     * the RPC will be closed with a [Status] [inferred][Status.fromException] from that
     * cause.  [Sending][kotlinx.coroutines.channels.SendChannel.send] to this channel may suspend
     * if additional responses
     * cannot be sent without excess buffering; see [io.grpc.ServerCall.Listener.onReady] for
     * details.
     */
    open suspend fun bidiStreamSayHello(requests: ReceiveChannel<HelloRequest>,
        responses: SendChannel<HelloReply>) {
      throw
          StatusException(UNIMPLEMENTED.withDescription("Method helloworld.Greeter.BidiStreamSayHello is unimplemented"))
    }

    final override fun bindService(): ServerServiceDefinition = builder(getServiceDescriptor())
      .addMethod(unaryServerMethodDefinition(
      scope = this,
      descriptor = GreeterGrpc.getSayHelloMethod(),
      implementation = ::sayHello
    ))
      .addMethod(clientStreamingServerMethodDefinition(
      scope = this,
      descriptor = GreeterGrpc.getClientStreamSayHelloMethod(),
      implementation = ::clientStreamSayHello
    ))
      .addMethod(serverStreamingServerMethodDefinition(
      scope = this,
      descriptor = GreeterGrpc.getServerStreamSayHelloMethod(),
      implementation = ::serverStreamSayHello
    ))
      .addMethod(bidiStreamingServerMethodDefinition(
      scope = this,
      descriptor = GreeterGrpc.getBidiStreamSayHelloMethod(),
      implementation = ::bidiStreamSayHello
    )).build()
  }
}
