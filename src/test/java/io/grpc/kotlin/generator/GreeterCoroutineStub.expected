import io.grpc.CallOptions
import io.grpc.CallOptions.DEFAULT
import io.grpc.Channel
import io.grpc.Metadata
import io.grpc.examples.helloworld.GreeterGrpc
import io.grpc.examples.helloworld.HelloReply
import io.grpc.examples.helloworld.HelloRequest
import io.grpc.examples.helloworld.MultiHelloRequest
import io.grpc.kotlin.AbstractCoroutineStub
import io.grpc.kotlin.ClientCalls.bidiStreamingRpc
import io.grpc.kotlin.ClientCalls.clientStreamingRpc
import io.grpc.kotlin.ClientCalls.serverStreamingRpc
import io.grpc.kotlin.ClientCalls.unaryRpc
import kotlin.coroutines.CoroutineContext
import kotlin.coroutines.EmptyCoroutineContext
import kotlin.jvm.JvmOverloads
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.withContext

/**
 * A stub for issuing RPCs to a(n) helloworld.Greeter service as suspending coroutines.
 */
class GreeterCoroutineStub @JvmOverloads constructor(
  channel: Channel,
  coroutineContext: CoroutineContext = EmptyCoroutineContext,
  callOptions: CallOptions = DEFAULT
) : AbstractCoroutineStub<GreeterCoroutineStub>(channel, coroutineContext, callOptions) {
  override fun build(
    channel: Channel,
    coroutineContext: CoroutineContext,
    callOptions: CallOptions
  ): GreeterCoroutineStub = GreeterCoroutineStub(channel, coroutineContext, callOptions)

  /**
   * Issues a unary helloworld.Greeter.SayHello RPC on this stub's [Channel].
   *
   * The implementation may launch further coroutines, which are run as if by
   * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
   * [java.util.concurrent.Executor] associated with the `Channel`.)
   *
   * @param request The single argument to the RPC, sent to the server.
   *
   * @return The single response from the server.  This coroutine suspends until the server
   * returns it and closes with [io.grpc.Status.OK], at which point this coroutine resumes with the
   * result. If the RPC fails (closes with another [io.grpc.Status]), this will fail with a
   * corresponding [io.grpc.StatusException].
   */
  suspend fun sayHello(request: HelloRequest, headers: Metadata = Metadata()): HelloReply =
      withContext(coroutineContext) {
    unaryRpc(
      this,
      channel,
      GreeterGrpc.getSayHelloMethod(),
      request,
      callOptions,
      headers
    )
  }
  /**
   * Issues a client streaming helloworld.Greeter.ClientStreamSayHello RPC on this stub's [Channel].
   *
   * The implementation may launch further coroutines, which are run as if by
   * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
   * [java.util.concurrent.Executor] associated with the `Channel`.)
   *
   * @param requests A [ReceiveChannel] of requests to be sent to the server;
   * expected to be provided, populated, and closed by the client.  When requests is closed,
   * the RPC stream will be closed; if it is closed with a nonnull cause, the RPC is cancelled
   * and the cause is sent to the server as the reason for cancellation.
   *
   * @return The single response from the server.  This coroutine suspends until the server
   * returns it and closes with [io.grpc.Status.OK], at which point this coroutine resumes with the
   * result. If the RPC fails (closes with another [io.grpc.Status]), this will fail with a
   * corresponding [io.grpc.StatusException].
   */
  suspend fun clientStreamSayHello(requests: ReceiveChannel<HelloRequest>, headers: Metadata =
      Metadata()): HelloReply = withContext(coroutineContext) {
    clientStreamingRpc(
      this,
      channel,
      GreeterGrpc.getClientStreamSayHelloMethod(),
      requests,
      callOptions,
      headers
    )
  }
  /**
   * Issues a server streaming helloworld.Greeter.ServerStreamSayHello RPC on this stub's [Channel].
   *
   * The implementation may launch further coroutines, which are run as if by
   * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
   * [java.util.concurrent.Executor] associated with the `Channel`.)
   *
   * @param request The single argument to the RPC, sent to the server.
   *
   * @return A [`ReceiveChannel<HelloReply>`][ReceiveChannel] for responses from the server.  If
   * cancelled, the RPC is shut down and a cancellation with that cause is sent to the server.
   * Alternately, if the RPC fails (closes with a [io.grpc.Status] other than `io.grpc.Status.OK`),
   * the
   * returned channel is [closed][kotlinx.coroutines.channels.SendChannel.close] with a
   * corresponding [io.grpc.StatusException].
   */
  fun serverStreamSayHello(request: MultiHelloRequest, headers: Metadata = Metadata()):
      ReceiveChannel<HelloReply> = serverStreamingRpc(
    CoroutineScope(coroutineContext),
    channel,
    GreeterGrpc.getServerStreamSayHelloMethod(),
    request,
    callOptions,
    headers
  )
  /**
   * Issues a bidirectional streaming helloworld.Greeter.BidiStreamSayHello RPC on this stub's
   * [Channel].
   *
   * The implementation may launch further coroutines, which are run as if by
   * [`withContext(coroutineContext)`][withContext].  (Some work may also be done in the
   * [java.util.concurrent.Executor] associated with the `Channel`.)
   *
   * @param requests A [ReceiveChannel] of requests to be sent to the server;
   * expected to be provided, populated, and closed by the client.  When requests is closed,
   * the RPC stream will be closed; if it is closed with a nonnull cause, the RPC is cancelled
   * and the cause is sent to the server as the reason for cancellation.
   *
   * @return A [`ReceiveChannel<HelloReply>`][ReceiveChannel] for responses from the server.  If
   * cancelled, the RPC is shut down and a cancellation with that cause is sent to the server.
   * Alternately, if the RPC fails (closes with a [io.grpc.Status] other than `io.grpc.Status.OK`),
   * the
   * returned channel is [closed][kotlinx.coroutines.channels.SendChannel.close] with a
   * corresponding [io.grpc.StatusException].
   */
  fun bidiStreamSayHello(requests: ReceiveChannel<HelloRequest>, headers: Metadata = Metadata()):
      ReceiveChannel<HelloReply> = bidiStreamingRpc(
    CoroutineScope(coroutineContext),
    channel,
    GreeterGrpc.getBidiStreamSayHelloMethod(),
    requests,
    callOptions,
    headers
  )}